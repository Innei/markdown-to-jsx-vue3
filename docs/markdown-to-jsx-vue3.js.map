{"version":3,"file":"markdown-to-jsx-vue3.js","sources":["../node_modules/unquote/index.js","../index.tsx","../site.tsx"],"sourcesContent":["var reg = /[\\'\\\"]/\n\nmodule.exports = function unquote(str) {\n  if (!str) {\n    return ''\n  }\n  if (reg.test(str.charAt(0))) {\n    str = str.substr(1)\n  }\n  if (reg.test(str.charAt(str.length - 1))) {\n    str = str.substr(0, str.length - 1)\n  }\n  return str\n}\n","/* @jsx h */\n/**\n * markdown-to-jsx@6 is a fork of [simple-markdown v0.2.2](https://github.com/Khan/simple-markdown)\n * from Khan Academy. Thank you Khan devs for making such an awesome and extensible\n * parsing infra... without it, half of the optimizations here wouldn't be feasible. üôèüèº\n */\nimport {\n  h as VueH,\n  defineComponent,\n  PropType,\n  VNode,\n  RenderFunction,\n} from 'vue'\n/// <reference path=\"unquote.d.ts\" />\nimport unquote from 'unquote'\n\n/**\n * RequireAtLeastOne<{ ... }> <- only requires at least one key\n */\ntype RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n  T,\n  Exclude<keyof T, Keys>\n> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n  }[Keys]\n\nexport type CreateElement = typeof VueH\n\nexport type HTMLTags = keyof JSX.IntrinsicElements\n\nexport type State = {\n  inAnchor?: boolean\n  inline?: boolean\n  inTable?: boolean\n  key?: string | number\n  list?: boolean\n  simple?: boolean\n}\n\nexport type ParserResult = {\n  [key: string]: any\n  type?: string\n}\n\nexport type NestedParser = (input: string, state?: State) => ParserResult\n\nexport type Parser<ParserOutput> = (\n  capture: RegExpMatchArray,\n  nestedParse: NestedParser,\n  state?: State\n) => ParserOutput\n\nexport type RuleOutput = (ast: ParserResult, state: State) => JSX.Element\n\nexport type Rule<ParserOutput = ParserResult> = {\n  match: (\n    source: string,\n    state: State,\n    prevCapturedString?: string\n  ) => RegExpMatchArray\n  order: Priority\n  parse: Parser<ParserOutput>\n  react?: (\n    node: ParserOutput,\n    output: RuleOutput,\n    state?: State\n  ) => ReturnType<RenderFunction>\n}\n\nexport type RuleName =\n  | 'blockQuote'\n  | 'breakLine'\n  | 'breakThematic'\n  | 'codeBlock'\n  | 'codeFenced'\n  | 'codeInline'\n  | 'footnote'\n  | 'footnoteReference'\n  | 'gfmTask'\n  | 'heading'\n  | 'headingSetext'\n  | 'htmlComment'\n  | 'image'\n  | 'link'\n  | 'linkAngleBraceStyleDetector'\n  | 'linkBareUrlDetector'\n  | 'linkMailtoDetector'\n  | 'list'\n  | 'newlineCoalescer'\n  | 'paragraph'\n  | 'ref'\n  | 'refImage'\n  | 'refLink'\n  | 'table'\n  | 'tableSeparator'\n  | 'text'\n  | 'textBolded'\n  | 'textEmphasized'\n  | 'textEscaped'\n  | 'textStrikethroughed'\n  | 'htmlBlock'\n  | 'htmlSelfClosing'\nexport type Rules = {\n  blockQuote: Rule\n  breakLine: Rule\n  breakThematic: Rule\n  codeBlock: Rule\n  codeFenced: Rule\n  codeInline: Rule\n  footnote: Rule\n  footnoteReference: Rule\n  gfmTask: Rule\n  heading: Rule\n  headingSetext: Rule\n  htmlComment: Rule\n  image: Rule\n  link: Rule\n  linkAngleBraceStyleDetector: Rule\n  linkBareUrlDetector: Rule\n  linkMailtoDetector: Rule\n  list: Rule\n  newlineCoalescer: Rule\n  paragraph: Rule\n  ref: Rule\n  refImage: Rule\n  refLink: Rule\n  table: Rule\n  tableSeparator: Rule\n  text: Rule\n  textBolded: Rule\n  textEmphasized: Rule\n  textEscaped: Rule\n  textStrikethroughed: Rule\n  htmlBlock: Rule\n  htmlSelfClosing: Rule\n  [key: string]: Rule\n}\n\nexport type Override =\n  | RequireAtLeastOne<{\n      component: VNode\n      props: Object\n    }>\n  | VNode\n\nexport type Overrides = {\n  [tag in HTMLTags]?: Override\n} & {\n  [customComponent: string]: Override\n}\nexport type ExtendsRules = Partial<\n  {\n    [key in RuleName]: Partial<Rule>\n  }\n>\n\nexport type Options = Partial<{\n  /**\n   * Ultimate control over the output of all rendered JSX.\n   */\n  createElement: (\n    tag: Parameters<CreateElement>[0],\n    props: any,\n    ...children: VNode[]\n  ) => JSX.Element\n\n  /**\n   * Disable the compiler's best-effort transcription of provided raw HTML\n   * into JSX-equivalent. This is the functionality that prevents the need to\n   * use `dangerouslySetInnerHTML` in React.\n   */\n  disableParsingRawHTML: boolean\n\n  /**\n   * Forces the compiler to always output content with a block-level wrapper\n   * (`<p>` or any block-level syntax your markdown already contains.)\n   */\n  forceBlock: boolean\n\n  /**\n   * Forces the compiler to always output content with an inline wrapper (`<span>`)\n   */\n  forceInline: boolean\n\n  /**\n   * Supply additional HTML entity: unicode replacement mappings.\n   *\n   * Pass only the inner part of the entity as the key,\n   * e.g. `&le;` -> `{ \"le\": \"\\u2264\" }`\n   *\n   * By default\n   * the following entites are replaced with their unicode equivalents:\n   *\n   * ```\n   * &amp;\n   * &apos;\n   * &gt;\n   * &lt;\n   * &nbsp;\n   * &quot;\n   * ```\n   */\n  namedCodesToUnicode: {\n    [key: string]: string\n  }\n\n  /**\n   * Selectively control the output of particular HTML tags as they would be\n   * emitted by the compiler.\n   */\n  overrides: Overrides\n\n  /**\n   * Declare the type of the wrapper to be used when there are multiple\n   * children to render. Set to `null` to get an array of children back\n   * without any wrapper, or use `React.Fragment` to get a React element\n   * that won't show up in the DOM.\n   */\n  wrapper: VNode | null\n\n  /**\n   * Forces the compiler to wrap results, even if there is only a single\n   * child or no children.\n   */\n  forceWrapper: boolean\n\n  /**\n   * Override normalization of non-URI-safe characters for use in generating\n   * HTML IDs for anchor linking purposes.\n   */\n  slugify: (source: string) => string\n\n  /**\n   * Add additional rules for parsing the markdown\n   */\n  additionalParserRules: {\n    [key: string]: Rule\n  }\n\n  extendsRules: ExtendsRules\n  /** @default [] */\n\n  disabledTypes: RuleName[]\n\n  allowedTypes: RuleName[]\n  /**\n   * @default ['script', 'style']\n   */\n  doNotProcessHtmlElements: HTMLTags[]\n}>\n\n/** TODO: Drop for React 16? */\nconst ATTRIBUTE_TO_JSX_PROP_MAP = {\n  accesskey: 'accessKey',\n  allowfullscreen: 'allowFullScreen',\n  allowtransparency: 'allowTransparency',\n  autocomplete: 'autoComplete',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  charset: 'charSet',\n  class: 'className',\n  classid: 'classId',\n  colspan: 'colSpan',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  crossorigin: 'crossOrigin',\n  enctype: 'encType',\n  for: 'htmlFor',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formmethod: 'formMethod',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  hreflang: 'hrefLang',\n  inputmode: 'inputMode',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  marginheight: 'marginHeight',\n  marginwidth: 'marginWidth',\n  maxlength: 'maxLength',\n  mediagroup: 'mediaGroup',\n  minlength: 'minLength',\n  novalidate: 'noValidate',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  rowspan: 'rowSpan',\n  spellcheck: 'spellCheck',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  tabindex: 'tabIndex',\n  usemap: 'useMap',\n} as const\n\nconst namedCodesToUnicode = {\n  amp: '\\u0026',\n  apos: '\\u0027',\n  gt: '\\u003e',\n  lt: '\\u003c',\n  nbsp: '\\u00a0',\n  quot: '\\u201c',\n} as const\n\nconst DO_NOT_PROCESS_HTML_ELEMENTS = ['style', 'script']\n\n/**\n * the attribute extractor regex looks for a valid attribute name,\n * followed by an equal sign (whitespace around the equal sign is allowed), followed\n * by one of the following:\n *\n * 1. a single quote-bounded string, e.g. 'foo'\n * 2. a double quote-bounded string, e.g. \"bar\"\n * 3. an interpolation, e.g. {something}\n *\n * JSX can be be interpolated into itself and is passed through the compiler using\n * the same options and setup as the current run.\n *\n * <Something children={<SomeOtherThing />} />\n *                      ==================\n *                              ‚Ü≥ children: [<SomeOtherThing />]\n *\n * Otherwise, interpolations are handled as strings or simple booleans\n * unless HTML syntax is detected.\n *\n * <Something color={green} disabled={true} />\n *                   =====            ====\n *                     ‚Üì                ‚Ü≥ disabled: true\n *                     ‚Ü≥ color: \"green\"\n *\n * Numbers are not parsed at this time due to complexities around int, float,\n * and the upcoming bigint functionality that would make handling it unwieldy.\n * Parse the string in your component as desired.\n *\n * <Something someBigNumber={123456789123456789} />\n *                           ==================\n *                                   ‚Ü≥ someBigNumber: \"123456789123456789\"\n */\nconst ATTR_EXTRACTOR_R =\n  /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi\n\n/** TODO: Write explainers for each of these */\n\nconst AUTOLINK_MAILTO_CHECK_R = /mailto:/i\nconst BLOCK_END_R = /\\n{2,}$/\nconst BLOCKQUOTE_R = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/\nconst BLOCKQUOTE_TRIM_LEFT_MULTILINE_R = /^ *> ?/gm\nconst BREAK_LINE_R = /^ {2,}\\n/\nconst BREAK_THEMATIC_R = /^(?:( *[-*_]) *){3,}(?:\\n *)+\\n/\nconst CODE_BLOCK_FENCED_R =\n  /^\\s*(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n?/\nconst CODE_BLOCK_R = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/\nconst CODE_INLINE_R = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/\nconst CONSECUTIVE_NEWLINE_R = /^(?:\\n *)*\\n/\nconst CR_NEWLINE_R = /\\r\\n?/g\nconst FOOTNOTE_R = /^\\[\\^([^\\]]+)](:.*)\\n/\nconst FOOTNOTE_REFERENCE_R = /^\\[\\^([^\\]]+)]/\nconst FORMFEED_R = /\\f/g\nconst GFM_TASK_R = /^\\s*?\\[(x|\\s)\\]/\nconst HEADING_R = /^ *(#{1,6}) *([^\\n]+?)(?: +#*)?(?:\\n *)*(?:\\n|$)/\nconst HEADING_SETEXT_R = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/\n\n/**\n * Explanation:\n *\n * 1. Look for a starting tag, preceeded by any amount of spaces\n *    ^ *<\n *\n * 2. Capture the tag name (capture 1)\n *    ([^ >/]+)\n *\n * 3. Ignore a space after the starting tag and capture the attribute portion of the tag (capture 2)\n *     ?([^>]*)\\/{0}>\n *\n * 4. Ensure a matching closing tag is present in the rest of the input string\n *    (?=[\\s\\S]*<\\/\\1>)\n *\n * 5. Capture everything until the matching closing tag -- this might include additional pairs\n *    of the same tag type found in step 2 (capture 3)\n *    ((?:[\\s\\S]*?(?:<\\1[^>]*>[\\s\\S]*?<\\/\\1>)*[\\s\\S]*?)*?)<\\/\\1>\n *\n * 6. Capture excess newlines afterward\n *    \\n*\n */\nconst HTML_BLOCK_ELEMENT_R =\n  /^ *(?!<[a-z][^ >/]* ?\\/>)<([a-z][^ >/]*) ?([^>]*)\\/{0}>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/i\n\nconst HTML_CHAR_CODE_R = /&([a-z]+);/g\n\nconst HTML_COMMENT_R = /^<!--[\\s\\S]*?(?:-->)/\n\n/**\n * borrowed from React 15(https://github.com/facebook/react/blob/894d20744cba99383ffd847dbd5b6e0800355a5c/src/renderers/dom/shared/HTMLDOMPropertyConfig.js)\n */\nconst HTML_CUSTOM_ATTR_R = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/\n\nconst HTML_SELF_CLOSING_ELEMENT_R =\n  /^ *<([a-z][a-z0-9:]*)(?:\\s+((?:<.*?>|[^>])*))?\\/?>(?!<\\/\\1>)(\\s*\\n)?/i\nconst INTERPOLATION_R = /^\\{.*\\}$/\nconst LINK_AUTOLINK_BARE_URL_R = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/\nconst LINK_AUTOLINK_MAILTO_R = /^<([^ >]+@[^ >]+)>/\nconst LINK_AUTOLINK_R = /^<([^ >]+:\\/[^ >]+)>/\nconst LIST_ITEM_END_R = / *\\n+$/\nconst LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/\nconst CAPTURE_LETTER_AFTER_HYPHEN = /-([a-z])?/gi\nconst NP_TABLE_R = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/\nconst PARAGRAPH_R = /^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/\nconst REFERENCE_IMAGE_OR_LINK = /^\\[([^\\]]*)\\]:\\s*(\\S+)\\s*(\"([^\"]*)\")?/\nconst REFERENCE_IMAGE_R = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/\nconst REFERENCE_LINK_R = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/\nconst SQUARE_BRACKETS_R = /(\\[|\\])/g\nconst SHOULD_RENDER_AS_BLOCK_R = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/\nconst TAB_R = /\\t/g\nconst TABLE_SEPARATOR_R = /^ *\\| */\nconst TABLE_TRIM_PIPES = /(^ *\\||\\| *$)/g\nconst TABLE_CELL_END_TRIM = / *$/\nconst TABLE_CENTER_ALIGN = /^ *:-+: *$/\nconst TABLE_LEFT_ALIGN = /^ *:-+ *$/\nconst TABLE_RIGHT_ALIGN = /^ *-+: *$/\nconst TEXT_BOLD_R =\n  /^([*_])\\1((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1\\1(?!\\1)/\nconst TEXT_EMPHASIZED_R =\n  /^([*_])((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1(?!\\1|\\w)/\nconst TEXT_STRIKETHROUGHED_R = /^~~((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)~~/\n\nconst TEXT_ESCAPED_R = /^\\\\([^0-9A-Za-z\\s])/\nconst TEXT_PLAIN_R =\n  /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff&;.()'\"]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i\nconst TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R = /(^\\n+|\\n+$|\\s+$)/g\n\nconst HTML_LEFT_TRIM_AMOUNT_R = /^([ \\t]*)/\n\nconst UNESCAPE_URL_R = /\\\\([^0-9A-Z\\s])/gi\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nconst LIST_BULLET = '(?:[*+-]|\\\\d+\\\\.)'\n\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nconst LIST_ITEM_PREFIX = '( *)(' + LIST_BULLET + ') +'\nconst LIST_ITEM_PREFIX_R = new RegExp('^' + LIST_ITEM_PREFIX)\n\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nconst LIST_ITEM_R = new RegExp(\n  LIST_ITEM_PREFIX +\n    '[^\\\\n]*(?:\\\\n' +\n    '(?!\\\\1' +\n    LIST_BULLET +\n    ' )[^\\\\n]*)*(\\\\n|$)',\n  'gm'\n)\n\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nconst LIST_R = new RegExp(\n  '^( *)(' +\n    LIST_BULLET +\n    ') ' +\n    '[\\\\s\\\\S]+?(?:\\\\n{2,}(?! )' +\n    '(?!\\\\1' +\n    LIST_BULLET +\n    ' (?!' +\n    LIST_BULLET +\n    ' ))\\\\n*' +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    '|\\\\s*\\\\n*$)'\n)\n\nconst LINK_INSIDE = '(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*'\nconst LINK_HREF_AND_TITLE =\n  '\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+[\\'\"]([\\\\s\\\\S]*?)[\\'\"])?\\\\s*'\n\nconst LINK_R = new RegExp(\n  '^\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n)\n\nconst IMAGE_R = new RegExp(\n  '^!\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n)\n\nconst BLOCK_SYNTAXES = [\n  BLOCKQUOTE_R,\n  CODE_BLOCK_R,\n  CODE_BLOCK_FENCED_R,\n  HEADING_R,\n  HEADING_SETEXT_R,\n  HTML_BLOCK_ELEMENT_R,\n  HTML_COMMENT_R,\n  HTML_SELF_CLOSING_ELEMENT_R,\n  LIST_ITEM_R,\n  LIST_R,\n  NP_TABLE_R,\n  PARAGRAPH_R,\n]\n\nfunction containsBlockSyntax(input: string) {\n  return BLOCK_SYNTAXES.some(r => r.test(input))\n}\n\n// based on https://stackoverflow.com/a/18123682/1141611\n// not complete, but probably good enough\nfunction slugify(str: string) {\n  return str\n    .replace(/[√Ä√Å√Ç√É√Ñ√Ö√†√°√¢√£√§√•√¶√Ü]/g, 'a')\n    .replace(/[√ß√á]/g, 'c')\n    .replace(/[√∞√ê]/g, 'd')\n    .replace(/[√à√â√ä√ã√©√®√™√´]/g, 'e')\n    .replace(/[√è√Ø√é√Æ√ç√≠√å√¨]/g, 'i')\n    .replace(/[√ë√±]/g, 'n')\n    .replace(/[√∏√ò≈ì≈í√ï√µ√î√¥√ì√≥√í√≤]/g, 'o')\n    .replace(/[√ú√º√õ√ª√ö√∫√ô√π]/g, 'u')\n    .replace(/[≈∏√ø√ù√Ω]/g, 'y')\n    .replace(/[^a-z0-9- ]/gi, '')\n    .replace(/ /gi, '-')\n    .toLowerCase()\n}\n\nfunction parseTableAlignCapture(alignCapture: string) {\n  if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n    return 'right'\n  } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n    return 'center'\n  } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n    return 'left'\n  }\n\n  return null\n}\n\nfunction parseTableRow(source: string, parse: NestedParser, state: State) {\n  const prevInTable = state.inTable\n  state.inTable = true\n  const tableRow = parse(source.trim(), state)\n  state.inTable = prevInTable\n\n  let cells = [[]]\n  tableRow.forEach(function (node, i) {\n    if (node.type === 'tableSeparator') {\n      // Filter out empty table separators at the start/end:\n      if (i !== 0 && i !== tableRow.length - 1) {\n        // Split the current row:\n        cells.push([])\n      }\n    } else {\n      if (\n        node.type === 'text' &&\n        (tableRow[i + 1] == null || tableRow[i + 1].type === 'tableSeparator')\n      ) {\n        node.content = node.content.replace(TABLE_CELL_END_TRIM, '')\n      }\n      cells[cells.length - 1].push(node)\n    }\n  })\n  return cells\n}\n\nfunction parseTableAlign(source: string /*, parse, state*/) {\n  const alignText = source.replace(TABLE_TRIM_PIPES, '').split('|')\n\n  return alignText.map(parseTableAlignCapture)\n}\n\nfunction parseTableCells(source: string, parse: NestedParser, state: State) {\n  const rowsText = source.trim().split('\\n')\n\n  return rowsText.map(function (rowText) {\n    return parseTableRow(rowText, parse, state)\n  })\n}\n\nfunction parseTable(\n  capture: RegExpMatchArray,\n  parse: NestedParser,\n  state: State\n) {\n  state.inline = true\n  const header = parseTableRow(capture[1], parse, state)\n  const align = parseTableAlign(capture[2])\n  const cells = parseTableCells(capture[3], parse, state)\n  state.inline = false\n\n  return {\n    align: align,\n    cells: cells,\n    header: header,\n    type: 'table',\n  }\n}\n\nfunction getTableStyle(node, colIndex) {\n  return node.align[colIndex] == null\n    ? {}\n    : {\n        textAlign: node.align[colIndex],\n      }\n}\n\n/** TODO: remove for react 16 */\nfunction normalizeAttributeKey(key) {\n  const hyphenIndex = key.indexOf('-')\n\n  if (hyphenIndex !== -1 && key.match(HTML_CUSTOM_ATTR_R) === null) {\n    key = key.replace(CAPTURE_LETTER_AFTER_HYPHEN, function (_, letter) {\n      return letter.toUpperCase()\n    })\n  }\n\n  return key\n}\n\nfunction attributeValueToJSXPropValue(\n  key: JSX.IntrinsicAttributes,\n  value: string\n): any {\n  if (key === 'style') {\n    return value.split(/;\\s?/).reduce(function (styles, kvPair) {\n      const key = kvPair.slice(0, kvPair.indexOf(':'))\n\n      // snake-case to camelCase\n      // also handles PascalCasing vendor prefixes\n      const camelCasedKey = key.replace(/(-[a-z])/g, substr =>\n        substr[1].toUpperCase()\n      )\n\n      // key.length + 1 to skip over the colon\n      styles[camelCasedKey] = kvPair.slice(key.length + 1).trim()\n\n      return styles\n    }, {})\n  } else if (key === 'href') {\n    return sanitizeUrl(value)\n  } else if (value.match(INTERPOLATION_R)) {\n    // return as a string and let the consumer decide what to do with it\n    value = value.slice(1, value.length - 1)\n  }\n\n  if (value === 'true') {\n    return true\n  } else if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n\nfunction normalizeWhitespace(source: string): string {\n  return source\n    .replace(CR_NEWLINE_R, '\\n')\n    .replace(FORMFEED_R, '')\n    .replace(TAB_R, '    ')\n}\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @rules: an object containing\n * rule type -> {match, order, parse} objects\n * (lower order is higher precedence)\n * (Note: `order` is added to defaultRules after creation so that\n *  the `order` of defaultRules in the source matches the `order`\n *  of defaultRules in terms of `order` fields.)\n *\n * @returns The resulting parse function, with the following parameters:\n *   @source: the input source string to be parsed\n *   @state: an optional object to be threaded through parse\n *     calls. Allows clients to add stateful operations to\n *     parsing, such as keeping track of how many levels deep\n *     some nesting is. For an example use-case, see passage-ref\n *     parsing in src/widgets/passage/passage-markdown.jsx\n */\nfunction parserFor(\n  rules: Rules\n): (source: string, state: State) => ReturnType<NestedParser> {\n  // Sorts rules in order of increasing order, then\n  // ascending rule name in case of ties.\n  let ruleList = Object.keys(rules)\n\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== 'production') {\n    ruleList.forEach(function (type) {\n      let order = rules[type].order\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        (typeof order !== 'number' || !isFinite(order))\n      ) {\n        console.warn(\n          'markdown-to-jsx: Invalid order for rule `' + type + '`: ' + order\n        )\n      }\n    })\n  }\n\n  ruleList.sort(function (typeA, typeB) {\n    let orderA = rules[typeA].order\n    let orderB = rules[typeB].order\n\n    // First sort based on increasing order\n    if (orderA !== orderB) {\n      return orderA - orderB\n\n      // Then based on increasing unicode lexicographic ordering\n    } else if (typeA < typeB) {\n      return -1\n    }\n\n    return 1\n  })\n\n  function nestedParse(source: string, state: State): ParserResult[] {\n    let result = []\n\n    // We store the previous capture so that match functions can\n    // use some limited amount of lookbehind. Lists use this to\n    // ensure they don't match arbitrary '- ' or '* ' in inline\n    // text (see the list rule for more information).\n    let prevCapture = ''\n    while (source) {\n      let i = 0\n      while (i < ruleList.length) {\n        const ruleType = ruleList[i]\n        const rule = rules[ruleType]\n        const capture = rule.match(source, state, prevCapture)\n\n        if (capture) {\n          const currCaptureString = capture[0]\n          source = source.substring(currCaptureString.length)\n          const parsed = rule.parse(capture, nestedParse, state)\n\n          // We also let rules override the default type of\n          // their parsed node if they would like to, so that\n          // there can be a single output function for all links,\n          // even if there are several rules to parse them.\n          if (parsed.type == null) {\n            parsed.type = ruleType\n          }\n\n          result.push(parsed)\n\n          prevCapture = currCaptureString\n          break\n        }\n\n        i++\n      }\n    }\n\n    return result\n  }\n\n  return function outerParse(source, state) {\n    return nestedParse(normalizeWhitespace(source), state)\n  }\n}\n\n// Creates a match function for an inline scoped or simple element from a regex\nexport function inlineRegex(regex: RegExp) {\n  return function match(source, state: State) {\n    if (state.inline) {\n      return regex.exec(source)\n    } else {\n      return null\n    }\n  }\n}\n\n// basically any inline element except links\nexport function simpleInlineRegex(regex: RegExp) {\n  return function match(source: string, state: State) {\n    if (state.inline || state.simple) {\n      return regex.exec(source)\n    } else {\n      return null\n    }\n  }\n}\n\n// Creates a match function for a block scoped element from a regex\nexport function blockRegex(regex: RegExp) {\n  return function match(source: string, state: State) {\n    if (state.inline || state.simple) {\n      return null\n    } else {\n      return regex.exec(source)\n    }\n  }\n}\n\n// Creates a match function from a regex, ignoring block/inline scope\nexport function anyScopeRegex(regex: RegExp) {\n  return function match(source: string /*, state*/) {\n    return regex.exec(source)\n  }\n}\n\nfunction reactFor(outputFunc) {\n  return function nestedReactOutput(\n    ast: ParserResult | ParserResult[],\n    state: State = {}\n  ): VNode[] {\n    if (Array.isArray(ast)) {\n      const oldKey = state.key\n      const result = []\n\n      // map nestedOutput over the ast, except group any text\n      // nodes together into a single string output.\n      let lastWasString = false\n\n      for (let i = 0; i < ast.length; i++) {\n        state.key = i\n\n        const nodeOut = nestedReactOutput(ast[i], state)\n        const isString = typeof nodeOut === 'string'\n\n        if (isString && lastWasString) {\n          result[result.length - 1] += nodeOut\n        } else {\n          result.push(nodeOut)\n        }\n\n        lastWasString = isString\n      }\n\n      state.key = oldKey\n\n      return result\n    }\n\n    return outputFunc(ast, nestedReactOutput, state)\n  }\n}\n\nexport function sanitizeUrl(url: string): string | null {\n  try {\n    const decoded = decodeURIComponent(url).replace(/[^A-Za-z0-9/:]/g, '')\n\n    if (decoded.match(/^\\s*(javascript|vbscript|data):/i)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          'Anchor URL contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.',\n          decoded\n        )\n      }\n\n      return null\n    }\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        'Anchor URL could not be decoded due to malformed syntax or characters, it will not be rendered.',\n        url\n      )\n    }\n\n    // decodeURIComponent sometimes throws a URIError\n    // See `decodeURIComponent('a%AFc');`\n    // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n    return null\n  }\n\n  return url\n}\n\nfunction unescapeUrl(rawUrlString: string): string {\n  return rawUrlString.replace(UNESCAPE_URL_R, '$1')\n}\n\nconst cloneElement = (VNode, props = {}) => {\n  const attrs = { ...VNode.data?.attrs, ...props }\n  const data = { ...VNode.data, attrs }\n\n  return { ...VNode, data }\n}\n\n/**\n * Everything inline, including links.\n */\nexport function parseInline(\n  parse: NestedParser,\n  content: string,\n  state: State\n): ParserResult {\n  const isCurrentlyInline = state.inline || false\n  const isCurrentlySimple = state.simple || false\n  state.inline = true\n  state.simple = true\n  const result = parse(content, state)\n  state.inline = isCurrentlyInline\n  state.simple = isCurrentlySimple\n  return result\n}\n\n/**\n * Anything inline that isn't a link.\n */\nexport function parseSimpleInline(\n  parse: NestedParser,\n  content: string,\n  state: State\n): ParserResult {\n  const isCurrentlyInline = state.inline || false\n  const isCurrentlySimple = state.simple || false\n  state.inline = false\n  state.simple = true\n  const result = parse(content, state)\n  state.inline = isCurrentlyInline\n  state.simple = isCurrentlySimple\n  return result\n}\n\nexport function parseBlock(parse, content, state: State): ParserResult {\n  state.inline = false\n  return parse(content + '\\n\\n', state)\n}\n\nexport const parseCaptureInline: Parser<ReturnType<typeof parseInline>> = (\n  capture,\n  parse,\n  state: State\n) => {\n  return {\n    content: parseInline(parse, capture[1], state),\n  }\n}\n\nfunction captureNothing() {\n  return {}\n}\n\nfunction renderNothing() {\n  return null\n}\n\nfunction ruleOutput(rules: Rules) {\n  return function nestedRuleOutput(\n    ast: ParserResult,\n    outputFunc: RuleOutput,\n    state: State\n  ) {\n    return rules[ast.type].react(ast, outputFunc, state)\n  }\n}\n\nfunction cx(...args) {\n  return args.filter(Boolean).join(' ')\n}\n\nfunction get(src: Object, path: string, fb?: any) {\n  let ptr = src\n  const frags = path.split('.')\n\n  while (frags.length) {\n    ptr = ptr[frags[0]]\n\n    if (ptr === undefined) break\n    else frags.shift()\n  }\n\n  return ptr || fb\n}\n\nfunction getTag(tag: string, overrides: Overrides) {\n  const override = get(overrides, tag)\n\n  if (!override) return tag\n\n  return typeof override === 'function' ||\n    (typeof override === 'object' && 'render' in override)\n    ? override\n    : get(overrides, `${tag}.component`, tag)\n}\n\nexport enum Priority {\n  /**\n   * anything that must scan the tree before everything else\n   */\n  MAX,\n  /**\n   * scans for block-level constructs\n   */\n  HIGH,\n  /**\n   * inline w/ more priority than other inline\n   */\n  MED,\n  /**\n   * inline elements\n   */\n  LOW,\n  /**\n   * bare text and stuff that is considered leftovers\n   */\n  MIN,\n}\n\nexport function compiler(markdown: string, options: Options = {}) {\n  options.overrides = options.overrides || {}\n  options.slugify = options.slugify || slugify\n  options.namedCodesToUnicode = options.namedCodesToUnicode\n    ? { ...namedCodesToUnicode, ...options.namedCodesToUnicode }\n    : namedCodesToUnicode\n  options.additionalParserRules = options.additionalParserRules || ({} as any)\n\n  const createElementFn = options.createElement || VueH\n\n  // eslint-disable-next-line no-unused-vars\n  function h(\n    // locally we always will render a known string tag\n    tag: HTMLTags,\n    props: Parameters<CreateElement>[1] & {\n      className?: string\n    },\n    ...children\n  ) {\n    const overrideProps = get(options.overrides, `${tag}.props`, {})\n\n    return createElementFn(\n      getTag(tag as string, options.overrides),\n      {\n        ...props,\n        ...overrideProps,\n        class:\n          cx(\n            props?.className,\n            props?.class,\n            overrideProps?.class,\n            overrideProps.className\n          ) || undefined,\n      },\n      ...children\n    )\n  }\n\n  function compile(input: string): JSX.Element {\n    let _inline = false\n\n    if (options.forceInline) {\n      _inline = true\n    } else if (!options.forceBlock) {\n      /**\n       * should not contain any block-level markdown like newlines, lists, headings,\n       * thematic breaks, blockquotes, tables, etc\n       */\n      _inline = SHOULD_RENDER_AS_BLOCK_R.test(input) === false\n    }\n\n    const arr = emitter(\n      parser(\n        _inline\n          ? input\n          : `${input.replace(TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R, '')}\\n\\n`,\n        { inline: _inline }\n      )\n    )\n\n    if (options.wrapper === null) {\n      return arr\n    }\n\n    const wrapper = options.wrapper || (_inline ? 'span' : 'div')\n    let jsx\n\n    if (arr.length > 1 || options.forceWrapper) {\n      jsx = arr\n    } else if (arr.length === 1) {\n      jsx = arr[0]\n\n      // TODO: remove this for React 16\n      if (typeof jsx === 'string') {\n        return <span key=\"outer\">{jsx}</span>\n      } else {\n        return jsx\n      }\n    } else {\n      // TODO: return null for React 16\n      jsx = null\n    }\n\n    return h(wrapper as any, { key: 'outer' }, jsx)\n  }\n\n  function attrStringToMap(str: string) {\n    const attributes = str.match(ATTR_EXTRACTOR_R)\n\n    return attributes\n      ? attributes.reduce(function (map, raw, index) {\n          const delimiterIdx = raw.indexOf('=')\n\n          if (delimiterIdx !== -1) {\n            const key = normalizeAttributeKey(raw.slice(0, delimiterIdx)).trim()\n            const value = unquote(raw.slice(delimiterIdx + 1).trim())\n\n            const mappedKey = ATTRIBUTE_TO_JSX_PROP_MAP[key] || key\n            const normalizedValue = (map[mappedKey] =\n              attributeValueToJSXPropValue(key, value))\n\n            if (\n              typeof normalizedValue === 'string' &&\n              (HTML_BLOCK_ELEMENT_R.test(normalizedValue) ||\n                HTML_SELF_CLOSING_ELEMENT_R.test(normalizedValue))\n            ) {\n              map[mappedKey] = cloneElement(compile(normalizedValue.trim()), {\n                key: index,\n              })\n            }\n          } else if (raw !== 'style') {\n            map[ATTRIBUTE_TO_JSX_PROP_MAP[raw] || raw] = true\n          }\n\n          return map\n        }, {})\n      : undefined\n  }\n\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof markdown !== 'string') {\n      throw new Error(`markdown-to-jsx: the first argument must be\n                             a string`)\n    }\n\n    if (\n      Object.prototype.toString.call(options.overrides) !== '[object Object]'\n    ) {\n      throw new Error(`markdown-to-jsx: options.overrides (second argument property) must be\n                             undefined or an object literal with shape:\n                             {\n                                htmltagname: {\n                                    component: string|ReactComponent(optional),\n                                    props: object(optional)\n                                }\n                             }`)\n    }\n  }\n  type FootNote = { footnote: string; identifier: string }\n  const footnotes: FootNote[] = []\n  const footnoteMap = new Map<string, FootNote>()\n  const refs: { [key: string]: { target: string; title: string } } = {}\n\n  /**\n   * each rule's react() output function goes through our custom h() JSX pragma;\n   * this allows the override functionality to be automatically applied\n   */\n  const rules: Partial<Rules> = {\n    blockQuote: {\n      match: blockRegex(BLOCKQUOTE_R),\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        return {\n          content: parse(\n            capture[0].replace(BLOCKQUOTE_TRIM_LEFT_MULTILINE_R, ''),\n            state\n          ),\n        }\n      },\n      react(node, output, state) {\n        return (\n          <blockquote key={state.key}>{output(node.content, state)}</blockquote>\n        )\n      },\n    } as Rule<{ content: ParserResult }>,\n\n    breakLine: {\n      match: anyScopeRegex(BREAK_LINE_R),\n      order: Priority.HIGH,\n      parse: captureNothing,\n      react(_, __, state) {\n        return <br key={state.key} />\n      },\n    },\n\n    breakThematic: {\n      match: blockRegex(BREAK_THEMATIC_R),\n      order: Priority.HIGH,\n      parse: captureNothing,\n      react(_, __, state) {\n        return <hr key={state.key} />\n      },\n    },\n\n    codeBlock: {\n      match: blockRegex(CODE_BLOCK_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[0].replace(/^ {4}/gm, '').replace(/\\n+$/, ''),\n          lang: undefined,\n        }\n      },\n\n      react(node, output, state) {\n        return (\n          <pre key={state.key}>\n            <code className={node.lang ? `lang-${node.lang}` : ''}>\n              {node.content}\n            </code>\n          </pre>\n        )\n      },\n    } as Rule<{ content: string; lang?: string }>,\n\n    codeFenced: {\n      match: blockRegex(CODE_BLOCK_FENCED_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[3],\n          lang: capture[2] || undefined,\n          type: 'codeBlock',\n        }\n      },\n    },\n\n    codeInline: {\n      match: simpleInlineRegex(CODE_INLINE_R),\n      order: Priority.LOW,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[2],\n        }\n      },\n      react(node, output, state) {\n        return <code key={state.key}>{node.content}</code>\n      },\n    } as Rule<{ content: string }>,\n\n    /**\n     * footnotes are emitted at the end of compilation in a special <footer> block\n     */\n    footnote: {\n      match: blockRegex(FOOTNOTE_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        const obj = {\n          footnote: capture[2],\n          identifier: capture[1],\n        }\n        footnotes.push(obj)\n        footnoteMap.set(obj.identifier, obj)\n\n        return {}\n      },\n      react: renderNothing,\n    },\n\n    footnoteReference: {\n      match: inlineRegex(FOOTNOTE_REFERENCE_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse*/) {\n        return {\n          content: capture[1],\n          target: `#${options.slugify(capture[1])}`,\n          footnoteMap,\n        }\n      },\n      react(node, output, state) {\n        return (\n          <a key={state.key} href={sanitizeUrl(node.target)}>\n            <sup key={state.key}>{node.content}</sup>\n          </a>\n        )\n      },\n    } as Rule<{ content: string; target: string }>,\n\n    gfmTask: {\n      match: inlineRegex(GFM_TASK_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          completed: capture[1].toLowerCase() === 'x',\n        }\n      },\n      react(node, output, state) {\n        return (\n          <input\n            checked={node.completed}\n            key={state.key}\n            readOnly\n            type=\"checkbox\"\n          />\n        )\n      },\n    } as Rule<{ completed: boolean }>,\n\n    heading: {\n      match: blockRegex(HEADING_R),\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        return {\n          content: parseInline(parse, capture[2], state),\n          id: options.slugify(capture[2]),\n          level: capture[1].length,\n        }\n      },\n      react(node, output, state) {\n        node.tag = `h${node.level}` as HTMLTags\n        return (\n          // @ts-ignore\n          <node.tag id={node.id} key={state.key}>\n            {output(node.content, state)}\n          </node.tag>\n        )\n      },\n    } as Rule<{\n      content: ParserResult\n      id: string\n      level: number\n      tag: HTMLTags\n    }>,\n\n    headingSetext: {\n      match: blockRegex(HEADING_SETEXT_R),\n      order: Priority.MAX,\n      parse(capture, parse, state) {\n        return {\n          content: parseInline(parse, capture[1], state),\n          level: capture[2] === '=' ? 1 : 2,\n          type: 'heading',\n        }\n      },\n    },\n\n    htmlComment: {\n      match: anyScopeRegex(HTML_COMMENT_R),\n      order: Priority.HIGH,\n      parse() {\n        return {}\n      },\n      react: renderNothing,\n    },\n\n    image: {\n      match: simpleInlineRegex(IMAGE_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          alt: capture[1],\n          target: unescapeUrl(capture[2]),\n          title: capture[3],\n        }\n      },\n      react(node, output, state) {\n        return (\n          <img\n            key={state.key}\n            alt={node.alt || undefined}\n            title={node.title || undefined}\n            src={sanitizeUrl(node.target)}\n          />\n        )\n      },\n    } as Rule<{ alt?: string; target: string; title?: string }>,\n\n    link: {\n      match: inlineRegex(LINK_R),\n      order: Priority.LOW,\n      parse(capture, parse, state) {\n        return {\n          content: parseSimpleInline(parse, capture[1], state),\n          target: unescapeUrl(capture[2]),\n          title: capture[3],\n        }\n      },\n      react(node, output, state) {\n        return (\n          <a key={state.key} href={sanitizeUrl(node.target)} title={node.title}>\n            {output(node.content, state)}\n          </a>\n        )\n      },\n    } as Rule<{\n      content: ParserResult\n      target: string\n      title?: string\n    }>,\n\n    // https://daringfireball.net/projects/markdown/syntax#autolink\n    linkAngleBraceStyleDetector: {\n      match: inlineRegex(LINK_AUTOLINK_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: [\n            {\n              content: capture[1],\n              type: 'text',\n            },\n          ],\n          target: capture[1],\n          type: 'link',\n        }\n      },\n    },\n\n    linkBareUrlDetector: {\n      match: (source, state) => {\n        if (state.inAnchor) {\n          return null\n        }\n        return inlineRegex(LINK_AUTOLINK_BARE_URL_R)(source, state)\n      },\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: [\n            {\n              content: capture[1],\n              type: 'text',\n            },\n          ],\n          target: capture[1],\n          title: undefined,\n          type: 'link',\n        }\n      },\n    },\n\n    linkMailtoDetector: {\n      match: inlineRegex(LINK_AUTOLINK_MAILTO_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        let address = capture[1]\n        let target = capture[1]\n\n        // Check for a `mailto:` already existing in the link:\n        if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n          target = 'mailto:' + target\n        }\n\n        return {\n          content: [\n            {\n              content: address.replace('mailto:', ''),\n              type: 'text',\n            },\n          ],\n          target: target,\n          type: 'link',\n        }\n      },\n    },\n\n    list: {\n      match(source, state, prevCapture) {\n        // We only want to break into a list if we are at the start of a\n        // line. This is to avoid parsing \"hi * there\" with \"* there\"\n        // becoming a part of a list.\n        // You might wonder, \"but that's inline, so of course it wouldn't\n        // start a list?\". You would be correct! Except that some of our\n        // lists can be inline, because they might be inside another list,\n        // in which case we can parse with inline scope, but need to allow\n        // nested lists inside this inline scope.\n        const isStartOfLine = LIST_LOOKBEHIND_R.exec(prevCapture)\n        const isListBlock = state.list || !state.inline\n\n        if (isStartOfLine && isListBlock) {\n          source = isStartOfLine[1] + source\n\n          return LIST_R.exec(source)\n        } else {\n          return null\n        }\n      },\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        const bullet = capture[2]\n        const ordered = bullet.length > 1\n        const start = ordered ? +bullet : undefined\n        const items = capture[0]\n          // recognize the end of a paragraph block inside a list item:\n          // two or more newlines at end end of the item\n          .replace(BLOCK_END_R, '\\n')\n          .match(LIST_ITEM_R)\n\n        let lastItemWasAParagraph = false\n        const itemContent = items.map(function (item, i) {\n          // We need to see how far indented the item is:\n          const space = LIST_ITEM_PREFIX_R.exec(item)[0].length\n\n          // And then we construct a regex to \"unindent\" the subsequent\n          // lines of the items by that amount:\n          const spaceRegex = new RegExp('^ {1,' + space + '}', 'gm')\n\n          // Before processing the item, we need a couple things\n          const content = item\n            // remove indents on trailing lines:\n            .replace(spaceRegex, '')\n            // remove the bullet:\n            .replace(LIST_ITEM_PREFIX_R, '')\n\n          // Handling \"loose\" lists, like:\n          //\n          //  * this is wrapped in a paragraph\n          //\n          //  * as is this\n          //\n          //  * as is this\n          const isLastItem = i === items.length - 1\n          const containsBlocks = content.indexOf('\\n\\n') !== -1\n\n          // Any element in a list is a block if it contains multiple\n          // newlines. The last element in the list can also be a block\n          // if the previous item in the list was a block (this is\n          // because non-last items in the list can end with \\n\\n, but\n          // the last item can't, so we just \"inherit\" this property\n          // from our previous element).\n          const thisItemIsAParagraph =\n            containsBlocks || (isLastItem && lastItemWasAParagraph)\n          lastItemWasAParagraph = thisItemIsAParagraph\n\n          // backup our state for restoration afterwards. We're going to\n          // want to set state._list to true, and state._inline depending\n          // on our list's looseness.\n          const oldStateInline = state.inline\n          const oldStateList = state.list\n          state.list = true\n\n          // Parse inline if we're in a tight list, or block if we're in\n          // a loose list.\n          let adjustedContent\n          if (thisItemIsAParagraph) {\n            state.inline = false\n            adjustedContent = content.replace(LIST_ITEM_END_R, '\\n\\n')\n          } else {\n            state.inline = true\n            adjustedContent = content.replace(LIST_ITEM_END_R, '')\n          }\n\n          const result = parse(adjustedContent, state)\n\n          // Restore our state before returning\n          state.inline = oldStateInline\n          state.list = oldStateList\n\n          return result\n        })\n\n        return {\n          items: itemContent,\n          ordered: ordered,\n          start: start,\n        }\n      },\n      react(node, output, state) {\n        const Tag = node.ordered ? 'ol' : 'ul'\n\n        return (\n          <Tag key={state.key} start={node.start}>\n            {node.items.map(function generateListItem(item, i) {\n              return <li key={i}>{output(item, state)}</li>\n            })}\n          </Tag>\n        )\n      },\n    } as Rule<{\n      items: ParserResult[]\n      ordered: boolean\n      start?: number\n    }>,\n\n    newlineCoalescer: {\n      match: blockRegex(CONSECUTIVE_NEWLINE_R),\n      order: Priority.LOW,\n      parse: captureNothing,\n      react(/*node, output, state*/) {\n        return '\\n'\n      },\n    },\n\n    paragraph: {\n      match: blockRegex(PARAGRAPH_R),\n      order: Priority.LOW,\n      parse: parseCaptureInline,\n      react(node, output, state) {\n        return <p key={state.key}>{output(node.content, state)}</p>\n      },\n    } as Rule<ReturnType<typeof parseCaptureInline>>,\n\n    ref: {\n      match: inlineRegex(REFERENCE_IMAGE_OR_LINK),\n      order: Priority.MAX,\n      parse(capture /*, parse*/) {\n        refs[capture[1]] = {\n          target: capture[2],\n          title: capture[4],\n        }\n\n        return {}\n      },\n      react: renderNothing,\n    },\n\n    refImage: {\n      match: simpleInlineRegex(REFERENCE_IMAGE_R),\n      order: Priority.MAX,\n      parse(capture) {\n        return {\n          alt: capture[1] || undefined,\n          ref: capture[2],\n        }\n      },\n      react(node, output, state) {\n        return (\n          <img\n            key={state.key}\n            alt={node.alt}\n            src={sanitizeUrl(refs[node.ref].target)}\n            title={refs[node.ref].title}\n          />\n        )\n      },\n    } as Rule<{ alt?: string; ref: string }>,\n\n    refLink: {\n      match: inlineRegex(REFERENCE_LINK_R),\n      order: Priority.MAX,\n      parse(capture, parse, state) {\n        return {\n          content: parse(capture[1], state),\n          fallbackContent: parse(\n            capture[0].replace(SQUARE_BRACKETS_R, '\\\\$1'),\n            state\n          ),\n          ref: capture[2],\n        }\n      },\n      react(node, output, state) {\n        return refs[node.ref] ? (\n          <a\n            key={state.key}\n            href={sanitizeUrl(refs[node.ref].target)}\n            title={refs[node.ref].title}\n          >\n            {output(node.content, state)}\n          </a>\n        ) : (\n          <span key={state.key}>{output(node.fallbackContent, state)}</span>\n        )\n      },\n    } as Rule<{\n      content: ParserResult\n      fallbackContent: ParserResult\n      ref: string\n    }>,\n\n    table: {\n      match: blockRegex(NP_TABLE_R),\n      order: Priority.HIGH,\n      parse: parseTable,\n      react(node, output, state) {\n        return (\n          <table key={state.key}>\n            <thead>\n              <tr>\n                {node.header.map(function generateHeaderCell(content, i) {\n                  return (\n                    <th key={i} style={getTableStyle(node, i)}>\n                      {output(content, state)}\n                    </th>\n                  )\n                })}\n              </tr>\n            </thead>\n\n            <tbody>\n              {node.cells.map(function generateTableRow(row, i) {\n                return (\n                  <tr key={i}>\n                    {row.map(function generateTableCell(content, c) {\n                      return (\n                        <td key={c} style={getTableStyle(node, c)}>\n                          {output(content, state)}\n                        </td>\n                      )\n                    })}\n                  </tr>\n                )\n              })}\n            </tbody>\n          </table>\n        )\n      },\n    } as Rule<ReturnType<typeof parseTable>>,\n\n    tableSeparator: {\n      match: function (source, state) {\n        if (!state.inTable) {\n          return null\n        }\n        return TABLE_SEPARATOR_R.exec(source)\n      },\n      order: Priority.HIGH,\n      parse: function () {\n        return { type: 'tableSeparator' }\n      },\n      // These shouldn't be reached, but in case they are, be reasonable:\n      react() {\n        return ' | '\n      },\n    },\n\n    text: {\n      // Here we look for anything followed by non-symbols,\n      // double newlines, or double-space-newlines\n      // We break on any symbol characters so that this grammar\n      // is easy to extend without needing to modify this regex\n      match: anyScopeRegex(TEXT_PLAIN_R),\n      order: Priority.MIN,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[0]\n            // nbsp -> unicode equivalent for named chars\n            .replace(HTML_CHAR_CODE_R, (full, inner) => {\n              return options.namedCodesToUnicode[inner]\n                ? options.namedCodesToUnicode[inner]\n                : full\n            }),\n        }\n      },\n      react(node /*, output, state*/) {\n        return node.content\n      },\n    } as Rule<{ content: string }>,\n\n    textBolded: {\n      match: simpleInlineRegex(TEXT_BOLD_R),\n      order: Priority.MED,\n      parse(capture, parse, state) {\n        return {\n          // capture[1] -> the syntax control character\n          // capture[2] -> inner content\n          content: parse(capture[2], state),\n        }\n      },\n      react(node, output, state) {\n        return <strong key={state.key}>{output(node.content, state)}</strong>\n      },\n    } as Rule<ReturnType<NestedParser>>,\n\n    textEmphasized: {\n      match: simpleInlineRegex(TEXT_EMPHASIZED_R),\n      order: Priority.LOW,\n      parse(capture, parse, state) {\n        return {\n          // capture[1] -> opening * or _\n          // capture[2] -> inner content\n          content: parse(capture[2], state),\n        }\n      },\n      react(node, output, state) {\n        return <em key={state.key}>{output(node.content, state)}</em>\n      },\n    } as Rule<ReturnType<NestedParser>>,\n\n    textEscaped: {\n      // We don't allow escaping numbers, letters, or spaces here so that\n      // backslashes used in plain text still get rendered. But allowing\n      // escaping anything else provides a very flexible escape mechanism,\n      // regardless of how this grammar is extended.\n      match: simpleInlineRegex(TEXT_ESCAPED_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[1],\n          type: 'text',\n        }\n      },\n    },\n\n    textStrikethroughed: {\n      match: simpleInlineRegex(TEXT_STRIKETHROUGHED_R),\n      order: Priority.LOW,\n      parse: parseCaptureInline,\n      react(node, output, state) {\n        return <del key={state.key}>{output(node.content, state)}</del>\n      },\n    } as Rule<ReturnType<typeof parseCaptureInline>>,\n\n    ...options.additionalParserRules,\n  }\n\n  // Object.keys(rules).forEach(key => {\n  //     let { match, parse } = rules[key];\n\n  //     rules[key]._match = (...args) => {\n  //         const start = performance.now();\n  //         const result = match(...args);\n  //         const delta = performance.now() - start;\n\n  //         if (delta > 5)\n  //             console.warn(\n  //                 `Slow match for ${key}: ${delta.toFixed(3)}ms, input: ${\n  //                     args[0]\n  //                 }`\n  //             );\n\n  //         return result;\n  //     };\n\n  //     rules[key]._parse = (...args) => {\n  //         const start = performance.now();\n  //         const result = parse(...args);\n  //         const delta = performance.now() - start;\n\n  //         if (delta > 5)\n  //             console.warn(`Slow parse for ${key}: ${delta.toFixed(3)}ms`);\n\n  //         console.log(`${key}:parse`, `${delta.toFixed(3)}ms`, args[0]);\n\n  //         return result;\n  //     };\n  // });\n\n  if (options.allowedTypes?.length) {\n    Object.keys(rules).forEach(key => {\n      if (!options.allowedTypes.includes(key as any)) {\n        delete rules[key]\n      }\n    })\n  } else if (options.disabledTypes?.length) {\n    options.disabledTypes.forEach(type => {\n      delete rules[type]\n    })\n  }\n\n  if (options.disableParsingRawHTML !== true) {\n    rules.htmlBlock = {\n      /**\n       * find the first matching end tag and process the interior\n       */\n      match: anyScopeRegex(HTML_BLOCK_ELEMENT_R),\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        const [, whitespace] = capture[3].match(HTML_LEFT_TRIM_AMOUNT_R)\n        const trimmer = new RegExp(`^${whitespace}`, 'gm')\n        const trimmed = capture[3].replace(trimmer, '')\n\n        const parseFunc = containsBlockSyntax(trimmed)\n          ? parseBlock\n          : parseInline\n\n        const tagName = capture[1].toLowerCase() as HTMLTags\n        const noInnerParse =\n          (\n            options.doNotProcessHtmlElements ?? DO_NOT_PROCESS_HTML_ELEMENTS\n          ).indexOf(tagName) !== -1\n\n        state.inAnchor = state.inAnchor || tagName === 'a'\n\n        /**\n         * if another html block is detected within, parse as block,\n         * otherwise parse as inline to pick up any further markdown\n         */\n        const content = noInnerParse\n          ? capture[3]\n          : parseFunc(parse, trimmed, state)\n\n        state.inAnchor = false\n\n        return {\n          attrs: attrStringToMap(capture[2]),\n          content,\n\n          noInnerParse,\n\n          tag: noInnerParse ? tagName : capture[1],\n        }\n      },\n      react(node, output, state) {\n        return (\n          // @ts-ignore\n          <node.tag key={state.key} {...node.attrs}>\n            {node.noInnerParse\n              ? (node.content as string)\n              : output(node.content as ParserResult, state)}\n          </node.tag>\n        )\n      },\n    } as Rule<{\n      attrs: ReturnType<typeof attrStringToMap>\n      content: string | ReturnType<NestedParser>\n      noInnerParse: Boolean\n      tag: string\n    }>\n\n    rules.htmlSelfClosing = {\n      /**\n       * find the first matching end tag and process the interior\n       */\n      match: anyScopeRegex(HTML_SELF_CLOSING_ELEMENT_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          attrs: attrStringToMap(capture[2] || ''),\n          tag: capture[1],\n        }\n      },\n      react(node, output, state) {\n        return h(node.tag, { ...node.attrs, key: state.key })\n      },\n    } as Rule<{\n      attrs: ReturnType<typeof attrStringToMap>\n      tag: string\n    }>\n  }\n\n  // merge extends rule\n\n  const extendsRules = options.extendsRules\n  if (extendsRules) {\n    for (const key in extendsRules) {\n      const originRule = rules[key]\n      if (!originRule) {\n        continue\n      }\n\n      Object.assign(rules[key], {\n        ...extendsRules[key],\n      })\n    }\n  }\n\n  const parser = parserFor(rules as Rules)\n  const emitter: Function = reactFor(ruleOutput(rules as Rules))\n\n  const jsx = compile(markdown)\n\n  if (footnotes.length) {\n    const Footer = (\n      <footer key=\"footer\">\n        {footnotes.map(function createFootnote(def) {\n          return (\n            <div id={options.slugify(def.identifier)} key={def.identifier}>\n              {def.identifier}\n              {emitter(parser(def.footnote, { inline: true }))}\n            </div>\n          )\n        })}\n      </footer>\n    )\n    if (Array.isArray(jsx)) {\n      jsx.push(Footer)\n    } else jsx.props.children.push(Footer)\n  }\n\n  return jsx\n}\n\n/**\n * A simple HOC for easy React use. Feed the markdown content as a direct child\n * and the rest is taken care of automatically.\n */\n\nconst Markdown = defineComponent({\n  props: {\n    options: {\n      type: Object as PropType<Options>,\n    },\n    props: {\n      type: Object as PropType<Record<string, any>>,\n    },\n  },\n  setup(props, { slots }) {\n    return () =>\n      cloneElement(\n        compiler(\n          slots.default?.()[0].children as any as string,\n          props.options || {}\n        ),\n        props.props || {}\n      )\n  },\n})\n\nexport default Markdown\n","// /* @jsx h */\n\nimport { createApp, defineComponent, h } from 'vue'\n\nimport Markdown from './index'\n\nconst MyComponent = defineComponent({\n  props: {},\n  setup() {\n    return () => h('h3', '---------MyComponent-------')\n  },\n})\n\nconst options = {\n  overrides: {\n    MyComponent: {\n      component: MyComponent,\n    },\n  },\n}\n\nconst content = document.getElementById('sample-content')!.textContent!.trim()\n\n// @ts-ignore\ncreateApp(h(Markdown, { options }, content)).mount('#root')\n"],"names":["reg","unquote","str","test","charAt","substr","length","ATTRIBUTE_TO_JSX_PROP_MAP","accesskey","allowfullscreen","allowtransparency","autocomplete","autofocus","autoplay","cellpadding","cellspacing","charset","classid","colspan","contenteditable","contextmenu","crossorigin","enctype","formaction","formenctype","formmethod","formnovalidate","formtarget","frameborder","hreflang","inputmode","keyparams","keytype","marginheight","marginwidth","maxlength","mediagroup","minlength","novalidate","radiogroup","readonly","rowspan","spellcheck","srcdoc","srclang","srcset","tabindex","usemap","namedCodesToUnicode","amp","apos","gt","lt","nbsp","quot","DO_NOT_PROCESS_HTML_ELEMENTS","ATTR_EXTRACTOR_R","AUTOLINK_MAILTO_CHECK_R","BLOCK_END_R","BLOCKQUOTE_R","BLOCKQUOTE_TRIM_LEFT_MULTILINE_R","BREAK_LINE_R","BREAK_THEMATIC_R","CODE_BLOCK_FENCED_R","CODE_BLOCK_R","CODE_INLINE_R","CONSECUTIVE_NEWLINE_R","CR_NEWLINE_R","FOOTNOTE_R","FOOTNOTE_REFERENCE_R","FORMFEED_R","GFM_TASK_R","HEADING_R","HEADING_SETEXT_R","HTML_BLOCK_ELEMENT_R","HTML_CHAR_CODE_R","HTML_COMMENT_R","HTML_CUSTOM_ATTR_R","HTML_SELF_CLOSING_ELEMENT_R","INTERPOLATION_R","LINK_AUTOLINK_BARE_URL_R","LINK_AUTOLINK_MAILTO_R","LINK_AUTOLINK_R","LIST_ITEM_END_R","LIST_LOOKBEHIND_R","CAPTURE_LETTER_AFTER_HYPHEN","NP_TABLE_R","PARAGRAPH_R","REFERENCE_IMAGE_OR_LINK","REFERENCE_IMAGE_R","REFERENCE_LINK_R","SQUARE_BRACKETS_R","SHOULD_RENDER_AS_BLOCK_R","TAB_R","TABLE_SEPARATOR_R","TABLE_TRIM_PIPES","TABLE_CELL_END_TRIM","TABLE_CENTER_ALIGN","TABLE_LEFT_ALIGN","TABLE_RIGHT_ALIGN","TEXT_BOLD_R","TEXT_EMPHASIZED_R","TEXT_STRIKETHROUGHED_R","TEXT_ESCAPED_R","TEXT_PLAIN_R","TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R","HTML_LEFT_TRIM_AMOUNT_R","UNESCAPE_URL_R","LIST_BULLET","LIST_ITEM_PREFIX","LIST_ITEM_PREFIX_R","RegExp","LIST_ITEM_R","LIST_R","LINK_INSIDE","LINK_HREF_AND_TITLE","LINK_R","IMAGE_R","BLOCK_SYNTAXES","containsBlockSyntax","input","some","r","slugify","replace","toLowerCase","parseTableAlignCapture","alignCapture","parseTableRow","source","parse","state","prevInTable","inTable","tableRow","trim","cells","forEach","node","i","type","push","content","parseTableAlign","alignText","split","map","parseTableCells","rowsText","rowText","parseTable","capture","inline","header","align","getTableStyle","colIndex","textAlign","normalizeAttributeKey","key","hyphenIndex","indexOf","match","_","letter","toUpperCase","attributeValueToJSXPropValue","value","reduce","styles","kvPair","slice","camelCasedKey","sanitizeUrl","normalizeWhitespace","parserFor","rules","ruleList","Object","keys","order","isFinite","console","warn","sort","typeA","typeB","orderA","orderB","nestedParse","result","prevCapture","ruleType","rule","currCaptureString","substring","parsed","outerParse","inlineRegex","regex","exec","simpleInlineRegex","simple","blockRegex","anyScopeRegex","reactFor","outputFunc","nestedReactOutput","ast","Array","isArray","oldKey","lastWasString","nodeOut","isString","url","decoded","decodeURIComponent","e","unescapeUrl","rawUrlString","cloneElement","VNode","props","attrs","data","parseInline","isCurrentlyInline","isCurrentlySimple","parseSimpleInline","parseBlock","parseCaptureInline","captureNothing","renderNothing","ruleOutput","nestedRuleOutput","react","cx","filter","Boolean","join","get","src","path","fb","ptr","frags","undefined","shift","getTag","tag","overrides","override","Priority","compiler","markdown","options","additionalParserRules","createElementFn","createElement","VueH","h","overrideProps","className","compile","_inline","forceInline","forceBlock","arr","emitter","parser","wrapper","jsx","forceWrapper","attrStringToMap","attributes","raw","index","delimiterIdx","mappedKey","normalizedValue","Error","prototype","toString","call","footnotes","footnoteMap","Map","refs","blockQuote","HIGH","output","breakLine","__","breakThematic","codeBlock","MAX","lang","codeFenced","codeInline","LOW","footnote","obj","identifier","set","footnoteReference","target","gfmTask","completed","heading","id","level","headingSetext","htmlComment","image","alt","title","link","linkAngleBraceStyleDetector","linkBareUrlDetector","inAnchor","linkMailtoDetector","address","list","isStartOfLine","isListBlock","bullet","ordered","start","items","lastItemWasAParagraph","itemContent","item","space","spaceRegex","isLastItem","containsBlocks","thisItemIsAParagraph","oldStateInline","oldStateList","adjustedContent","Tag","generateListItem","newlineCoalescer","paragraph","ref","refImage","refLink","fallbackContent","table","generateHeaderCell","generateTableRow","row","generateTableCell","c","tableSeparator","text","MIN","full","inner","textBolded","MED","textEmphasized","textEscaped","textStrikethroughed","allowedTypes","includes","disabledTypes","disableParsingRawHTML","htmlBlock","whitespace","trimmer","trimmed","parseFunc","tagName","noInnerParse","doNotProcessHtmlElements","htmlSelfClosing","extendsRules","originRule","assign","Footer","createFootnote","def","children","Markdown","defineComponent","setup","slots","MyComponent","component","document","getElementById","textContent","createApp","mount"],"mappings":"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"}